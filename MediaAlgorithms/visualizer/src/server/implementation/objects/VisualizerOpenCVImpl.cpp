/* Autogenerated with kurento-module-creator */

#include "VisualizerOpenCVImpl.hpp"
#include <KurentoException.hpp>

using namespace std;
using namespace cv;
using namespace tinyxml2;

namespace kurento
{
namespace module
{
namespace visualizer
{

VisualizerOpenCVImpl::VisualizerOpenCVImpl ()
{
}

VisualizerOpenCVImpl::~VisualizerOpenCVImpl ()
{
}

/*
 * This function will be called with each new frame. mat variable
 * contains the current frame. You should insert your image processing code
 * here. Any changes in mat, will be sent through the Media Pipeline.
 */
void VisualizerOpenCVImpl::process (cv::Mat &mat)
{

        //Get the color & binary images from the input image
        Mat color_img(mat.rows,mat.cols,CV_8UC3);
        Mat bin_img(mat.rows,mat.cols,CV_8UC1);
        Mat out[] = {color_img, bin_img};
        int from_to[] = {0,0,1,1,2,2,3,3};
        mixChannels(&mat,1,out,2,from_to,4);

        threshold(bin_img,bin_img,0,255,0);

        //Count all the blobs
        unsigned int nblobs = static_cast<unsigned int>(labelBigBlobs(bin_img,50));

        //If no blobs found terminate this iteration
        if(nblobs == 0)
        {   
                return;
        }   

        std::vector<cv::Point> centroids;
        std::vector<int> areas;
        std::vector<float> radius;
        std::vector<int> contours;
        std::vector<cv::Rect> boxes;
        if(!area_centroid_radius(bin_img,centroids,areas,radius,contours,boxes)) return;

        if(centroids.size() != nblobs || areas.size() != nblobs || radius.size() != nblobs || contours.size() != nblobs || boxes.size() != nblobs) return;

        for(unsigned int i = 0; i < boxes.size(); i++)
        {
				switch(method)
				{
					case 1://"Bounding Box"
					{
						if(boxes[i].x < 0 || boxes[i].y < 0 || boxes[i].width <= 0 || boxes[i].height <= 0)
							return;

						rectangle(color_img,boxes[i],Scalar(color[2],color[1],color[0]),2);
					}
					break;

					case 2://"Enclosing Circle"
					{
						if(radius[i] <= 0 || centroids[i].x < 0 || centroids[i].y < 0 || centroids[i].x >= color_img.cols || centroids[i].y >= color_img.rows)
							return;

						circle(color_img,centroids[i],radius[i],Scalar(color[2],color[1],color[0]),2);
					}
					break;

					case 3://"Text Tag"
					{
						//String text = "B";
                		                Point textp;
                		                textp.x = centroids[i].x - 1;if(textp.x < 0)textp.x = 0;
                		                textp.y = centroids[i].y - 1;if(textp.y < 0)textp.y = 0;
		                                //putText(color_img,"P",textp,CV_FONT_HERSHEY_SIMPLEX,1.4,Scalar(0,0,255),2);
						if(text == "" || textp.x < 0 || textp.y < 0 || textp.x >= color_img.cols || textp.y >= color_img.rows)
							return;

						putText(color_img,text,textp,CV_FONT_HERSHEY_SIMPLEX,1.0,Scalar(color[2],color[1],color[0]),2);
					}
					break;

					case 4://"Filling Object"
					{
						if(radius[i] <= 0 || centroids[i].x < 0 || centroids[i].y < 0 || centroids[i].x >= color_img.cols || centroids[i].y >= color_img.rows)
							return;

						Mat mask(mat.rows,mat.cols,CV_8UC1,Scalar(0));
						//Method 1
						//bin_img(boxes[i]).copyTo(mask);
						//Method 2
						threshold(bin_img, mask, 128, 128, THRESH_BINARY);
						floodFill(mask, centroids[i], Scalar(255));
						threshold(mask, mask, 200, 255, THRESH_BINARY);
						//Result
						color_img.setTo(Scalar(color[2],color[1],color[0]),mask);
					}
					break;
				}
        }

        //Output the final image
        cvtColor(color_img,mat,CV_BGR2BGRA);

}

//Load variables from xml file
void VisualizerOpenCVImpl::setConfiguration(const std::string &file)
{
	XMLDocument xmlDoc;
	XMLError eResult = xmlDoc.LoadFile(file.c_str());

	if(!(eResult == XML_SUCCESS)) return;

	XMLNode *pRoot = xmlDoc.FirstChild();
	if(pRoot == nullptr) return;

	XMLElement *pElement = pRoot->FirstChildElement("VisualizerColor");
	std::string detectionColor = pElement->GetText();

	pElement = pRoot->FirstChildElement("VisualizerMethod");
	method = stoi(pElement->GetText());

	pElement = pRoot->FirstChildElement("VisualizerText");
	text = pElement->GetText();

	size_t pos = 0;
	color.clear();
	while ((pos = detectionColor.find(",")) != std::string::npos) {
	    //color.insert(color.end(),stoi(detectionColor.substr(0, pos)));
            color.push_back(stoi(detectionColor.substr(0, pos)));
	    detectionColor.erase(0, pos + 1);
	}
	color.push_back(stoi(detectionColor.substr(0, pos)));

	//return true;
}



} /* visualizer */
} /* module */
} /* kurento */
