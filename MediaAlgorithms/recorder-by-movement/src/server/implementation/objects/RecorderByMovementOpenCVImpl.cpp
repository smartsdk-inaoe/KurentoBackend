/* Autogenerated with kurento-module-creator */

#include "RecorderByMovementOpenCVImpl.hpp"
#include <KurentoException.hpp>
#include <string>
#include <sstream>

using namespace std;
using namespace cv; 
using namespace tinyxml2;


namespace kurento
{
namespace module
{
namespace recorderbymovement
{

//Initializing of variables
RecorderByMovementOpenCVImpl::RecorderByMovementOpenCVImpl ()
{
	pName = nullptr;
	pModule = nullptr;
	pFunction = nullptr;
	pArgs = nullptr;
	pValue = nullptr;
	pythonState = 0;
	configLoaded = false;

	color_rec = NULL;
	minArea = 4000;
	recordDelay = 10;
	stablePeriod = 50;
	recording = false;
	frameCount = 0;
	delayCount = 0;
	path = "/path/to/kurento/videos";
	cameraId = "0";
}

RecorderByMovementOpenCVImpl::~RecorderByMovementOpenCVImpl ()
{
	Py_XDECREF(pName);
	Py_XDECREF(pModule);
	Py_XDECREF(pFunction);
	Py_XDECREF(pArgs);
	Py_XDECREF(pValue);

	if(color_rec != NULL) delete color_rec;
}

//Kurento calls this method for every frame in the stream
void RecorderByMovementOpenCVImpl::process (cv::Mat &mat)
{
	//Check that the configuration file is loaded and the python interpreter is initialized
	if(!configLoaded || pythonState != 0)
	{
		Mat img(mat.rows,mat.cols,CV_8UC3);
		img = Scalar(0,0,255);
		if(!configLoaded) putText(img,"Config not loaded",Point(0,img.rows/2),CV_FONT_HERSHEY_SIMPLEX,1.0,Scalar(255,0,0));
		if(pythonState != 0)
		{
			ostringstream oss;
			oss << pythonState;
			putText(img,"Python error: "+oss.str(),Point(0,img.rows/2+30),CV_FONT_HERSHEY_SIMPLEX,1.0,Scalar(255,0,0));
		}
		cvtColor(img,mat,CV_BGR2BGRA);

		return;
	}

	//Get subsense binary image from alpha channel
	vector<Mat> split_images;
	split(mat,split_images);

	//Give the background subtractor time to stabilize
	if(frameCount < stablePeriod)
	{
		frameCount++;
		return;
	}

	//Count how many foreground pixels are
	int area = 0;
	for(int j = 0; j < split_images[3].rows; j++)
	{
		for(int i = 0; i < split_images[3].cols; i++)
		{
			if(split_images[3].at<uchar>(j,i) != 0) area++;
		}
	}

	//Decide whether to start or stop recording and send notifications to the context broker
	if(!recording && area > minArea)
	{
		//Build the name of the video file to be stored
		time_t t = time(0);
		struct tm* now = localtime(&t);
		char s[25];
		sprintf(s,"0_%s_%04d-%02d-%02d_%02d-%02d-%02d",cameraId.c_str(),(now->tm_year+1900),(now->tm_mon+1),now->tm_mday,now->tm_hour,now->tm_min,now->tm_sec);
		string c_file_name(path+"/"+s+".avi");

		//Initialize video writer
		Size frameSize(mat.cols,mat.rows);
		color_rec = new VideoWriter;
		color_rec->open(c_file_name,CV_FOURCC('D','I','V','X'),25,frameSize,true);
		recording = true;

		/*
		//Set up arguments of python function (3 arguments)
		pArgs = PyTuple_New(3);
		//First argument: name of json file (data model)
		pValue = PyString_FromString(jsonFile.c_str());
		PyTuple_SetItem(pArgs,0,pValue);

		//Second argument: list of model attributes to update
		pValue = PyString_FromString(parameterName.c_str());
		PyTuple_SetItem(pArgs,1,pValue);

		//Third argument: list of values of attributes timestamp,cameraid and 'Start' flag
		char dt[60];
		sprintf(dt,"%04d-%02d-%02dT%02d:%02d:%02d,%s,Start",(now->tm_year+1900),(now->tm_mon+1),now->tm_mday,now->tm_hour,now->tm_min,now->tm_sec,cameraId.c_str());
		pValue = PyString_FromString(dt);
		PyTuple_SetItem(pArgs,2,pValue);

		//Call the python function
		pValue = PyObject_CallObject(pFunction,pArgs);
		*/
	}
	else if(recording && area < minArea)
	{
		delayCount++;
		if(delayCount > recordDelay)
		{
			delete color_rec;
			color_rec = NULL;
			recording = false;

			/*
			//Set up arguments
			pArgs = PyTuple_New(3);
			pValue = PyString_FromString(jsonFile.c_str());
			PyTuple_SetItem(pArgs,0,pValue);
			pValue = PyString_FromString(parameterName.c_str());
			PyTuple_SetItem(pArgs,1,pValue);
			time_t t = time(0);
			struct tm* now = localtime(&t);
			char dt[60];
			sprintf(dt,"%04d-%02d-%02dT%02d:%02d:%02d,%s,Stop",(now->tm_year+1900),(now->tm_mon+1),now->tm_mday,now->tm_hour,now->tm_min,now->tm_sec,cameraId.c_str());
			pValue = PyString_FromString(dt);
			PyTuple_SetItem(pArgs,2,pValue);

			//Call the python function
			pValue = PyObject_CallObject(pFunction,pArgs);
			*/
		}
	}
	else if(recording && area > minArea) delayCount = 0;

	//Record video without the last channel
	if(recording)
	{
		Mat img(mat.rows,mat.cols,CV_8UC3);
		Mat img_array[] = {split_images[0], split_images[1], split_images[2]};
		merge(img_array,3,img);
		color_rec->write(img);
		color_rec->write(img);
		color_rec->write(img);
	}

}

//Load variables from xml file
bool RecorderByMovementOpenCVImpl::load(string file)
{
	XMLDocument xmlDoc;
	XMLError eResult = xmlDoc.LoadFile(file.c_str());
	if(!XMLCheckResult(eResult)) return false;

	XMLNode *pRoot = xmlDoc.FirstChild();
	if(pRoot == nullptr) return false;

	XMLElement *pElement = pRoot->FirstChildElement("PythonFile");
	pythonFile = pElement->GetText();

	pElement = pRoot->FirstChildElement("PythonFunction");
	pythonFunction = pElement->GetText();

	pElement = pRoot->FirstChildElement("JsonFile");
	jsonFile = pElement->GetText();

	pElement = pRoot->FirstChildElement("ParameterName");
	parameterName = pElement->GetText();

	pElement = pRoot->FirstChildElement("VideoPath");
	path = pElement->GetText();

	pElement = pRoot->FirstChildElement("CameraId");
	cameraId = pElement->GetText();

	return true;
}

bool RecorderByMovementOpenCVImpl::XMLCheckResult(XMLError result)
{
	return (result == XML_SUCCESS);
}

void RecorderByMovementOpenCVImpl::loadConfig(const std::string &file)
{
	if(configLoaded) return;

	configLoaded = load(file);

	if(!configLoaded) return;

	Py_Initialize();
	pName = PyString_FromString(pythonFile.c_str());
	pModule = PyImport_Import(pName);

	if(pName == nullptr)
	{
		pythonState = 1;
		return;
	}

	if(pModule == nullptr)
	{
		pythonState = 2;
		return;
	}

	pFunction = PyObject_GetAttrString(pModule,pythonFunction.c_str());

	if(pFunction == nullptr)
	{
		pythonState = 3;
		return;
	}

	if(!PyCallable_Check(pFunction))
	{
		pythonState = 4;
		return;
	}
}

} /* recorderbymovement */
} /* module */
} /* kurento */
