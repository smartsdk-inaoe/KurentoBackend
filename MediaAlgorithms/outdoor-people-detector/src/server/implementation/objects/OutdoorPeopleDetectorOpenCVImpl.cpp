/* Autogenerated with kurento-module-creator */

#include "OutdoorPeopleDetectorOpenCVImpl.hpp"
#include <KurentoException.hpp>
#include <fstream>
#include <ctime>

using namespace std;
using namespace cv;
using namespace tinyxml2;

namespace kurento
{
namespace module
{
namespace outdoorpeopledetector
{

OutdoorPeopleDetectorOpenCVImpl::OutdoorPeopleDetectorOpenCVImpl ():
classifier_()
{
	//Initialize database loading flag
	datasetLoaded = false;
}

OutdoorPeopleDetectorOpenCVImpl::~OutdoorPeopleDetectorOpenCVImpl ()
{
}

/*
 * This function will be called with each new frame. mat variable
 * contains the current frame. You should insert your image processing code
 * here. Any changes in mat, will be sent through the Media Pipeline.
 */
void OutdoorPeopleDetectorOpenCVImpl::process (cv::Mat &mat)
{
//In case of some error
        if(!datasetLoaded)
        {   
                Mat error_img(mat.rows,mat.cols,CV_8UC3);
                Scalar error_color = Scalar(0,0,255);
                error_img = error_color;
                putText(error_img,"Error: dataset not found",Point(0,error_img.rows/2),CV_FONT_HERSHEY_SIMPLEX,2.0,Scalar(255,0,0));
                cvtColor(error_img,mat,CV_BGR2BGRA);
                return;
        }

        //Get the color & binary images from the input image
        Mat color_img(mat.rows,mat.cols,CV_8UC3);
        Mat bin_img(mat.rows,mat.cols,CV_8UC1);
        Mat out[] = {color_img, bin_img};
        int from_to[] = {0,0,1,1,2,2,3,3};
        mixChannels(&mat,1,out,2,from_to,4);

        threshold(bin_img,bin_img,0,255,0);

        //Count all the blobs
        unsigned int nblobs = static_cast<unsigned int>(labelBigBlobs(bin_img,50));

        //If no blobs found terminate this iteration
        if(nblobs == 0)
        {   
                return;
        }   

        std::vector<cv::Point> centroids;
        std::vector<int> areas;
        std::vector<float> radius;
        std::vector<int> contours;
        std::vector<cv::Rect> boxes;
        if(!area_centroid_radius(bin_img,centroids,areas,radius,contours,boxes)) return;
        std::vector<FeatVec> features;

        if(centroids.size() != nblobs || areas.size() != nblobs || radius.size() != nblobs || contours.size() != nblobs || boxes.size() != nblobs) return;


        for(unsigned int i = 0;i < centroids.size(); i++)
        {   
                //If any of the contour values is zero, then end this iteration
                if(radius[i] == 0 || areas[i] == 0 || boxes[i].height == 0 || boxes[i].width == 0 || contours[i] == 0) return;

                float circleArea = 3.1415926535897 * pow(radius[i],2);
                circleArea = (circleArea - areas[i]) / circleArea;
                float aspectRatio = boxes[i].height / boxes[i].width;
                FeatVec fv(areas[i], circleArea, contours[i], aspectRatio);
                features.push_back(fv);
        }   


        //Classification phase
        classifier_.classify4(features,params);
        vector<int> results = classifier_.getResult();

        //Draw a bounding box on each blob
        for(unsigned int i = 0; i < boxes.size(); i++)
        {
                rectangle(color_img,boxes[i],Scalar(0,255,0));
        }

        //Draw tag on detected people
        if(centroids.size() == results.size())
        {   
                for(unsigned int i = 0; i < results.size(); i++)
                {
                        if(results[i]==2)
                        {
				switch(method)
				{
					case 1://"Bounding Box"
					{
						if(boxes[i].x < 0 || boxes[i].y < 0 || boxes[i].width <= 0 || boxes[i].height <= 0)
							return;

						rectangle(color_img,boxes[i],Scalar(color[2],color[1],color[0]),2);
					}
					break;

					case 2://"Enclosing Circle"
					{
						if(radius[i] <= 0 || centroids[i].x < 0 || centroids[i].y < 0 || centroids[i].x >= color_img.cols || centroids[i].y >= color_img.rows)
							return;

						circle(color_img,centroids[i],radius[i],Scalar(color[2],color[1],color[0]),2);
					}
					break;

					case 3://"Text Tag"
					{
						//String text = "V";
                		                Point textp;
                		                textp.x = centroids[i].x - 1;if(textp.x < 0)textp.x = 0;
                		                textp.y = centroids[i].y - 1;if(textp.y < 0)textp.y = 0;
		                                //putText(color_img,"P",textp,CV_FONT_HERSHEY_SIMPLEX,1.4,Scalar(0,0,255),2);
						if(text == "" || textp.x < 0 || textp.y < 0 || textp.x >= color_img.cols || textp.y >= color_img.rows)
							return;

						cv::putText(color_img,text,textp,CV_FONT_HERSHEY_SIMPLEX,1.0,Scalar(color[2],color[1],color[0]),2);
					}
					break;

					case 4://"Filling Object"
					{
						if(radius[i] <= 0 || centroids[i].x < 0 || centroids[i].y < 0 || centroids[i].x >= color_img.cols || centroids[i].y >= color_img.rows)
							return;

						Mat mask(mat.rows,mat.cols,CV_8UC1,Scalar(0));
						//Method 1
						//bin_img(boxes[i]).copyTo(mask);
						//Method 2
						threshold(bin_img, mask, 128, 128, THRESH_BINARY);
						floodFill(mask, centroids[i], Scalar(255));
						threshold(mask, mask, 200, 255, THRESH_BINARY);
						//Result
						color_img.setTo(Scalar(color[2],color[1],color[0]),mask);
					}
					break;
				}
                        }
                }
        }

        //Output the final image
        cvtColor(color_img,mat,CV_BGR2BGRA);

}

void OutdoorPeopleDetectorOpenCVImpl::setDB(const std::string &db)
{
        //Classification setup
        datasetLoaded = classifier_.load(db);
        aspectNormalizer = classifier_.maxAspect();
        float maxArea = static_cast<float>(classifier_.maxArea());
        float maxContour = static_cast<float>(classifier_.maxContour());
        float maxAspect = classifier_.maxAspect();
        float singleClassThresh = 0.75;
        float multiClassThresh = 0.24;
        params.push_back(1);
        params.push_back(1);
        params.push_back(0);
        params.push_back(1);
        params.push_back(maxArea);
        params.push_back(maxContour);
        params.push_back(maxAspect);
        params.push_back(singleClassThresh);
        params.push_back(multiClassThresh);
}

//Load variables from xml file
void OutdoorPeopleDetectorOpenCVImpl::setConfiguration(const std::string &file)
{
	XMLDocument xmlDoc;
	XMLError eResult = xmlDoc.LoadFile(file.c_str());

	if(!(eResult == XML_SUCCESS)) return;

	XMLNode *pRoot = xmlDoc.FirstChild();
	if(pRoot == nullptr) return;

	XMLElement *pElement = pRoot->FirstChildElement("OutdoorPeopleColor");
	std::string detectionColor = pElement->GetText();

	pElement = pRoot->FirstChildElement("OutdoorPeopleMethod");
	method = stoi(pElement->GetText());

	pElement = pRoot->FirstChildElement("OutdoorPeopleText");
	text = pElement->GetText();

	size_t pos = 0;
	color.clear();
	while ((pos = detectionColor.find(",")) != std::string::npos) {
	    //color.insert(color.end(),stoi(detectionColor.substr(0, pos)));
            color.push_back(stoi(detectionColor.substr(0, pos)));
	    detectionColor.erase(0, pos + 1);
	}
	color.push_back(stoi(detectionColor.substr(0, pos)));

	//return true;
}


} /* outdoorpeopledetector */
} /* module */
} /* kurento */
